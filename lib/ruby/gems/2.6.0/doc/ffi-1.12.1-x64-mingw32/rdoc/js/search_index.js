var search_data = {"index":{"searchIndex":["ffi","autopointer","callablereleaser","defaultreleaser","releaser","bitmask","constgenerator","constant","dataconverter","enum","enums","generator","task","io","library","managedstruct","notfounderror","platform","platformerror","pointer","strptrconverter","struct","managedstructconverter","structbyreference","structgenerator","field","structlayout","enum","innerstruct","mapped","structlayoutbuilder","typesgenerator","union","variadicinvoker","<<()","[]()","[]()","[]()","__map_symbol()","add()","add_array()","add_field()","add_struct()","add_typedef()","align()","align()","align()","aligned()","alignment()","alignment()","alignment=()","array_layout()","attach()","attach_function()","attach_variable()","auto_ptr()","autorelease=()","autorelease?()","bitmask()","bsd?()","build()","builder()","by_ref()","by_value()","calculate()","calculate()","call()","call()","callback()","callback()","clear()","const()","constants()","converted_value()","dump_config()","dump_constants()","enclosing_module()","enum()","enum_type()","enum_value()","errno()","errno=()","extended()","ffi_convention()","ffi_lib()","ffi_lib_flags()","ffi_libraries()","field()","field_for_type()","find()","find()","find_field_type()","find_type()","find_type()","find_type()","for_fd()","found?()","free()","free()","from_native()","from_native()","from_native()","from_native()","from_native()","from_native()","from_native()","function_names()","generate()","generate_layout()","generic_enum()","get()","get()","get()","get_field()","hash_layout()","in()","include()","include()","init()","is_os()","layout()","mac?()","map_library_name()","members()","members()","name()","native_read()","native_type()","native_type()","native_type()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","offset=()","offset_of()","offset_of()","offset_of()","offsets()","offsets()","offsets()","options()","options()","options=()","options=()","out()","pack()","packed()","packed=()","ptr()","put()","put()","put()","read()","read_array_of_type()","read_string()","read_string_length()","read_string_to_null()","release()","release()","ruby_name()","size()","size()","size()","size=()","size=()","solaris?()","struct()","symbol_map()","symbols()","to_config()","to_h()","to_hash()","to_native()","to_native()","to_native()","to_native()","to_ptr()","to_ptr()","to_ruby()","to_ruby()","to_s()","type_size()","typedef()","typedef()","union=()","union?()","unix?()","val()","values()","windows?()","write()","write_array_of_type()","write_string()","write_string_length()","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf","types.conf"],"longSearchIndex":["ffi","ffi::autopointer","ffi::autopointer::callablereleaser","ffi::autopointer::defaultreleaser","ffi::autopointer::releaser","ffi::bitmask","ffi::constgenerator","ffi::constgenerator::constant","ffi::dataconverter","ffi::enum","ffi::enums","ffi::generator","ffi::generator::task","ffi::io","ffi::library","ffi::managedstruct","ffi::notfounderror","ffi::platform","ffi::platformerror","ffi::pointer","ffi::strptrconverter","ffi::struct","ffi::struct::managedstructconverter","ffi::structbyreference","ffi::structgenerator","ffi::structgenerator::field","ffi::structlayout","ffi::structlayout::enum","ffi::structlayout::innerstruct","ffi::structlayout::mapped","ffi::structlayoutbuilder","ffi::typesgenerator","ffi::union","ffi::variadicinvoker","ffi::enums#<<()","ffi::bitmask#[]()","ffi::constgenerator#[]()","ffi::enum#[]()","ffi::enums#__map_symbol()","ffi::structlayoutbuilder#add()","ffi::structlayoutbuilder#add_array()","ffi::structlayoutbuilder#add_field()","ffi::structlayoutbuilder#add_struct()","ffi::add_typedef()","ffi::struct#align()","ffi::struct::align()","ffi::structlayoutbuilder#align()","ffi::struct::aligned()","ffi::struct#alignment()","ffi::struct::alignment()","ffi::structlayoutbuilder#alignment=()","ffi::struct::array_layout()","ffi::variadicinvoker#attach()","ffi::library#attach_function()","ffi::library#attach_variable()","ffi::struct::auto_ptr()","ffi::autopointer#autorelease=()","ffi::autopointer#autorelease?()","ffi::library#bitmask()","ffi::platform::bsd?()","ffi::structlayoutbuilder#build()","ffi::union::builder()","ffi::struct::by_ref()","ffi::struct::by_value()","ffi::constgenerator#calculate()","ffi::structgenerator#calculate()","ffi::autopointer::releaser#call()","ffi::variadicinvoker#call()","ffi::library#callback()","ffi::struct::callback()","ffi::struct#clear()","ffi::constgenerator#const()","ffi::generator#constants()","ffi::constgenerator::constant#converted_value()","ffi::structgenerator#dump_config()","ffi::constgenerator#dump_constants()","ffi::struct::enclosing_module()","ffi::library#enum()","ffi::library#enum_type()","ffi::library#enum_value()","ffi::errno()","ffi::errno=()","ffi::library::extended()","ffi::library#ffi_convention()","ffi::library#ffi_lib()","ffi::library#ffi_lib_flags()","ffi::library#ffi_libraries()","ffi::structgenerator#field()","ffi::structlayoutbuilder#field_for_type()","ffi::enum#find()","ffi::enums#find()","ffi::struct::find_field_type()","ffi::find_type()","ffi::library#find_type()","ffi::struct::find_type()","ffi::io::for_fd()","ffi::structgenerator#found?()","ffi::autopointer#free()","ffi::autopointer::releaser#free()","ffi::autopointer::from_native()","ffi::bitmask#from_native()","ffi::dataconverter#from_native()","ffi::enum#from_native()","ffi::strptrconverter::from_native()","ffi::struct::managedstructconverter#from_native()","ffi::structbyreference#from_native()","ffi::library#function_names()","ffi::typesgenerator::generate()","ffi::structgenerator#generate_layout()","ffi::library#generic_enum()","ffi::structlayout::enum#get()","ffi::structlayout::innerstruct#get()","ffi::structlayout::mapped#get()","ffi::structgenerator#get_field()","ffi::struct::hash_layout()","ffi::struct::in()","ffi::constgenerator#include()","ffi::structgenerator#include()","ffi::variadicinvoker#init()","ffi::platform::is_os()","ffi::struct::layout()","ffi::platform::mac?()","ffi::map_library_name()","ffi::struct#members()","ffi::struct::members()","ffi::structgenerator#name()","ffi::io::native_read()","ffi::autopointer::native_type()","ffi::dataconverter#native_type()","ffi::structbyreference#native_type()","ffi::autopointer::new()","ffi::autopointer::releaser::new()","ffi::bitmask::new()","ffi::constgenerator::new()","ffi::constgenerator::constant::new()","ffi::enum::new()","ffi::enums::new()","ffi::generator::new()","ffi::generator::task::new()","ffi::managedstruct::new()","ffi::notfounderror::new()","ffi::struct::managedstructconverter::new()","ffi::structbyreference::new()","ffi::structgenerator::new()","ffi::structgenerator::field::new()","ffi::structlayout::mapped::new()","ffi::structlayoutbuilder::new()","ffi::structgenerator::field#offset=()","ffi::struct::offset_of()","ffi::struct#offset_of()","ffi::structlayout#offset_of()","ffi::struct#offsets()","ffi::struct::offsets()","ffi::structlayout#offsets()","ffi::constgenerator::options()","ffi::structgenerator::options()","ffi::constgenerator::options=()","ffi::structgenerator::options=()","ffi::struct::out()","ffi::struct::pack()","ffi::struct::packed()","ffi::structlayoutbuilder#packed=()","ffi::struct::ptr()","ffi::structlayout::enum#put()","ffi::structlayout::innerstruct#put()","ffi::structlayout::mapped#put()","ffi::pointer#read()","ffi::pointer#read_array_of_type()","ffi::pointer#read_string()","ffi::pointer#read_string_length()","ffi::pointer#read_string_to_null()","ffi::autopointer::callablereleaser#release()","ffi::autopointer::defaultreleaser#release()","ffi::constgenerator::constant#ruby_name()","ffi::pointer::size()","ffi::struct::size()","ffi::struct#size()","ffi::struct::size=()","ffi::structlayoutbuilder#size=()","ffi::platform::solaris?()","ffi::generator#struct()","ffi::enum#symbol_map()","ffi::enum#symbols()","ffi::structgenerator::field#to_config()","ffi::enum#to_h()","ffi::enum#to_hash()","ffi::bitmask#to_native()","ffi::dataconverter#to_native()","ffi::enum#to_native()","ffi::structbyreference#to_native()","ffi::pointer#to_ptr()","ffi::struct#to_ptr()","ffi::constgenerator#to_ruby()","ffi::constgenerator::constant#to_ruby()","ffi::generator#to_s()","ffi::type_size()","ffi::typedef()","ffi::library#typedef()","ffi::structlayoutbuilder#union=()","ffi::structlayoutbuilder#union?()","ffi::platform::unix?()","ffi::struct::val()","ffi::struct#values()","ffi::platform::windows?()","ffi::pointer#write()","ffi::pointer#write_array_of_type()","ffi::pointer#write_string()","ffi::pointer#write_string_length()","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"info":[["FFI","","FFI.html","","<p>Copyright (C) 2008-2010 Wayne Meissner Copyright (C) 2008 Mike Dalessio\n<p>This file is part of ruby-ffi. …\n"],["FFI::AutoPointer","","FFI/AutoPointer.html","",""],["FFI::AutoPointer::CallableReleaser","","FFI/AutoPointer/CallableReleaser.html","","<p>CallableReleaser is a {Releaser} used when an {AutoPointer} is defined with a Proc or a Method.\n"],["FFI::AutoPointer::DefaultReleaser","","FFI/AutoPointer/DefaultReleaser.html","","<p>DefaultReleaser is a {Releaser} used when an {AutoPointer} is defined without Proc or Method. In this …\n"],["FFI::AutoPointer::Releaser","","FFI/AutoPointer/Releaser.html","","<p>@abstract Base class for {AutoPointer}&#39;s releasers.\n\n<pre>All subclasses of Releaser should define a +#release(ptr)+ ...</pre>\n"],["FFI::Bitmask","","FFI/Bitmask.html","","<p>Represents a C enum whose values are power of 2\n<p>@example\n\n<pre>enum {\n  red = (1&lt;&lt;0),\n  green = (1&lt;&lt;1),\n  blue ...</pre>\n"],["FFI::ConstGenerator","","FFI/ConstGenerator.html","","<p>ConstGenerator turns C constants into ruby values.\n<p>@example a simple example for stdio\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;ffi/tools/const_generator&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["FFI::ConstGenerator::Constant","","FFI/ConstGenerator/Constant.html","","<p>This class hold constants for {ConstGenerator}\n"],["FFI::DataConverter","","FFI/DataConverter.html","","<p>This module is used to extend somes classes and give then a common API.\n<p>Most of methods defined here must …\n"],["FFI::Enum","","FFI/Enum.html","","<p>Represents a C enum.\n<p>For a C enum:\n\n<pre>enum fruits {\n  apple,\n  banana,\n  orange,\n  pineapple\n};</pre>\n"],["FFI::Enums","","FFI/Enums.html","","<p>An instance of this class permits to manage {Enum}s. In fact, Enums is a collection of {Enum}s.\n"],["FFI::Generator","","FFI/Generator.html","","<p>Generate files with C structs for FFI::Struct and C constants.\n<p>A simple example\n<p>In file <code>zlib.rb.ffi</code>:\n"],["FFI::Generator::Task","","FFI/Generator/Task.html","","<p>Add Rake tasks that generate files with C structs for FFI::Struct and C constants.\n<p>@example a simple example …\n"],["FFI::IO","","FFI/IO.html","","<p>This module implements a couple of class methods to play with IO.\n"],["FFI::Library","","FFI/Library.html","","<p>This module is the base to use native functions.\n<p>A basic usage may be:\n\n<pre>require &#39;ffi&#39;\n\nmodule Hello\n  extend ...</pre>\n"],["FFI::ManagedStruct","","FFI/ManagedStruct.html","","<p>FFI::ManagedStruct allows custom garbage-collection of your FFI::Structs.\n<p>The typical use case would be …\n"],["FFI::NotFoundError","","FFI/NotFoundError.html","","<p>Exception raised when a function is not found in libraries\n"],["FFI::Platform","","FFI/Platform.html","","<p>This module defines different constants and class methods to play with various platforms.\n"],["FFI::PlatformError","","FFI/PlatformError.html","",""],["FFI::Pointer","","FFI/Pointer.html","",""],["FFI::StrPtrConverter","","FFI/StrPtrConverter.html","","<p>This will convert a pointer to a Ruby string (just like `:string`), but also allow to work with the pointer …\n"],["FFI::Struct","","FFI/Struct.html","",""],["FFI::Struct::ManagedStructConverter","","FFI/Struct/ManagedStructConverter.html","",""],["FFI::StructByReference","","FFI/StructByReference.html","","<p>This class includes the {FFI::DataConverter} module.\n"],["FFI::StructGenerator","","FFI/StructGenerator.html","","<p>Generates an FFI Struct layout.\n<p>Given the @@@ portion in:\n\n<pre>class Zlib::ZStream &lt; FFI::Struct\n  @@@\n  name ...</pre>\n"],["FFI::StructGenerator::Field","","FFI/StructGenerator/Field.html","","<p>A field in a Struct.\n"],["FFI::StructLayout","","FFI/StructLayout.html","",""],["FFI::StructLayout::Enum","","FFI/StructLayout/Enum.html","","<p>An enum {Field} in a {StructLayout}.\n"],["FFI::StructLayout::InnerStruct","","FFI/StructLayout/InnerStruct.html","",""],["FFI::StructLayout::Mapped","","FFI/StructLayout/Mapped.html","",""],["FFI::StructLayoutBuilder","","FFI/StructLayoutBuilder.html","","<p>Build a {StructLayout struct layout}.\n"],["FFI::TypesGenerator","","FFI/TypesGenerator.html","","<p>@private\n"],["FFI::Union","","FFI/Union.html","",""],["FFI::VariadicInvoker","","FFI/VariadicInvoker.html","",""],["<<","FFI::Enums","FFI/Enums.html#method-i-3C-3C","(enum)","<p>@param [Enum] enum Add an {Enum} to the collection.\n"],["[]","FFI::Bitmask","FFI/Bitmask.html#method-i-5B-5D","(*query)","<p>Get a symbol list or a value from the bitmask @overload [](*query)\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Get</span> <span class=\"ruby-identifier\">bitmask</span> <span class=\"ruby-identifier\">value</span> <span class=\"ruby-identifier\">from</span> <span class=\"ruby-identifier\">symbol</span> <span class=\"ruby-identifier\">list</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["[]","FFI::ConstGenerator","FFI/ConstGenerator.html#method-i-5B-5D","(name)","<p>@param [String] name @return constant value (converted if a <code>converter</code> was defined). Access a constant …\n"],["[]","FFI::Enum","FFI/Enum.html#method-i-5B-5D","(query)","<p>Get a symbol or a value from the enum. @overload [](query)\n\n<pre>Get enum value from symbol.\n@param [Symbol] ...</pre>\n"],["__map_symbol","FFI::Enums","FFI/Enums.html#method-i-__map_symbol","(symbol)","<p>@param symbol a symbol to find in merge symbol maps of all enums. @return a symbol\n"],["add","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-add","(name, type, offset = nil)","<p>@param [String, Symbol] name name of the field @param [Array, DataConverter, Struct, StructLayout::Field …\n"],["add_array","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-add_array","(name, type, count, offset = nil)","<p>@param name (see #add) @param type (see #add) @param [Numeric] count array length @param offset (see …\n"],["add_field","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-add_field","(name, type, offset = nil)","<p>@param (see #add) @return (see #add) Same as {#add}. @see #add\n"],["add_struct","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-add_struct","(name, type, offset = nil)","<p>@param (see #add) @return (see #add) Add a struct as a field to the builder.\n"],["add_typedef","FFI","FFI.html#method-c-add_typedef","(old, add)","<p>(see FFI.typedef)\n"],["align","FFI::Struct","FFI/Struct.html#method-i-align","()",""],["align","FFI::Struct","FFI/Struct.html#method-c-align","(alignment = 1)",""],["align","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-align","(offset, align)","<p>@param [Numeric] offset @param [Numeric] align @return [Numeric]\n"],["aligned","FFI::Struct","FFI/Struct.html#method-c-aligned","(alignment = 1)",""],["alignment","FFI::Struct","FFI/Struct.html#method-i-alignment","()","<p>@return [Fixnum] Struct alignment\n"],["alignment","FFI::Struct","FFI/Struct.html#method-c-alignment","()","<p>@return (see Struct#alignment)\n"],["alignment=","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-alignment-3D","(align)","<p>Set alignment attribute with <code>align</code> only if it is greater than attribute value. @param [Numeric] align …\n"],["array_layout","FFI::Struct","FFI/Struct.html#method-c-array_layout","(builder, spec)","<p>@param [StructLayoutBuilder] builder @param [Array&lt;Symbol, Integer&gt;] spec @return [builder] Add …\n"],["attach","FFI::VariadicInvoker","FFI/VariadicInvoker.html#method-i-attach","(mod, mname)","<p>Attach the invoker to module <code>mod</code> as <code>mname</code>\n"],["attach_function","FFI::Library","FFI/Library.html#method-i-attach_function","(name, func, args, returns = nil, options = nil)","<p>@overload attach_function(func, args, returns, options = {})\n\n<pre>@example attach function without an explicit ...</pre>\n"],["attach_variable","FFI::Library","FFI/Library.html#method-i-attach_variable","(mname, a1, a2 = nil)","<p>@overload attach_variable(mname, cname, type)\n\n<pre>@param [#to_s] mname name of ruby method to attach as\n@param ...</pre>\n"],["auto_ptr","FFI::Struct","FFI/Struct.html#method-c-auto_ptr","()",""],["autorelease=","FFI::AutoPointer","FFI/AutoPointer.html#method-i-autorelease-3D","(autorelease)","<p>@param [Boolean] autorelease @return [Boolean] <code>autorelease</code> Set <code>autorelease</code> property. See {Pointer Autorelease …\n"],["autorelease?","FFI::AutoPointer","FFI/AutoPointer.html#method-i-autorelease-3F","()","<p>@return [Boolean] <code>autorelease</code> Get <code>autorelease</code> property. See {Pointer Autorelease section at Pointer}. …\n"],["bitmask","FFI::Library","FFI/Library.html#method-i-bitmask","(*args)","<p>@overload bitmask(name, values)\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Create</span> <span class=\"ruby-identifier\">a</span> <span class=\"ruby-identifier\">named</span> <span class=\"ruby-identifier\">bitmask</span>\n<span class=\"ruby-ivar\">@example</span>\n <span class=\"ruby-identifier\">bitmask</span> <span class=\"ruby-value\">:foo</span>, [<span class=\"ruby-value\">:red</span>, <span class=\"ruby-value\">:green</span>, <span class=\"ruby-value\">:blue</span>] <span class=\"ruby-comment\"># ...</span>\n</pre>\n"],["bsd?","FFI::Platform","FFI/Platform.html#method-c-bsd-3F","()","<p>Test if current OS is a *BSD (include MAC) @return [Boolean]\n"],["build","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-build","()","<p>@return [StructLayout] Build and return the struct layout.\n"],["builder","FFI::Union","FFI/Union.html#method-c-builder","()",""],["by_ref","FFI::Struct","FFI/Struct.html#method-c-by_ref","(flags = :inout)",""],["by_value","FFI::Struct","FFI/Struct.html#method-c-by_value","()",""],["calculate","FFI::ConstGenerator","FFI/ConstGenerator.html#method-i-calculate","(options = {})","<p>Calculate constants values. @param [Hash] options @option options [String] :cppflags flags for C compiler …\n"],["calculate","FFI::StructGenerator","FFI/StructGenerator.html#method-i-calculate","(options = {})",""],["call","FFI::AutoPointer::Releaser","FFI/AutoPointer/Releaser.html#method-i-call","(*args)","<p>@param args Release pointer if <code>autorelease</code> is set.\n"],["call","FFI::VariadicInvoker","FFI/VariadicInvoker.html#method-i-call","(*args, &block)",""],["callback","FFI::Library","FFI/Library.html#method-i-callback","(*args)","<p>@overload callback(name, params, ret)\n\n<pre>@param name callback name to add to type map\n@param [Array] params ...</pre>\n"],["callback","FFI::Struct","FFI/Struct.html#method-c-callback","(params, ret)",""],["clear","FFI::Struct","FFI/Struct.html#method-i-clear","()","<p>Clear the struct content. @return [self]\n"],["const","FFI::ConstGenerator","FFI/ConstGenerator.html#method-i-const","(name, format = nil, cast = '', ruby_name = nil, converter = nil, &converter_proc)","<p>Request the value for C constant <code>name</code>.\n<p>@param [#to_s] name C constant name @param [String] format a printf …\n"],["constants","FFI::Generator","FFI/Generator.html#method-i-constants","(options = {}, &block)",""],["converted_value","FFI::ConstGenerator::Constant","FFI/ConstGenerator/Constant.html#method-i-converted_value","()","<p>Return constant value (converted if a <code>converter</code> was defined). @return constant value.\n"],["dump_config","FFI::StructGenerator","FFI/StructGenerator.html#method-i-dump_config","(io)",""],["dump_constants","FFI::ConstGenerator","FFI/ConstGenerator.html#method-i-dump_constants","(io)","<p>Dump constants to <code>io</code>. @param [#puts] io @return [nil]\n"],["enclosing_module","FFI::Struct","FFI/Struct.html#method-c-enclosing_module","()",""],["enum","FFI::Library","FFI/Library.html#method-i-enum","(*args)","<p>@overload enum(name, values)\n\n<pre>Create a named enum.\n@example\n enum :foo, [:zero, :one, :two]  # named enum ...</pre>\n"],["enum_type","FFI::Library","FFI/Library.html#method-i-enum_type","(name)","<p>@param name @return [FFI::Enum] Find an enum by name.\n"],["enum_value","FFI::Library","FFI/Library.html#method-i-enum_value","(symbol)","<p>@param symbol @return [FFI::Enum] Find an enum by a symbol it contains.\n"],["errno","FFI","FFI.html#method-c-errno","()","<p>@return (see FFI::LastError.error) @see FFI::LastError.error\n"],["errno=","FFI","FFI.html#method-c-errno-3D","(error)","<p>@param error (see FFI::LastError.error=) @return (see FFI::LastError.error=) @see FFI::LastError.error= …\n"],["extended","FFI::Library","FFI/Library.html#method-c-extended","(mod)","<p>@param mod extended object @return [nil] @raise {RuntimeError} if <code>mod</code> is not a Module Test if extended …\n"],["ffi_convention","FFI::Library","FFI/Library.html#method-i-ffi_convention","(convention = nil)","<p>Set the calling convention for {#attach_function} and {#callback}\n<p>@see en.wikipedia.org/wiki/Stdcall#stdcall …\n"],["ffi_lib","FFI::Library","FFI/Library.html#method-i-ffi_lib","(*names)","<p>@param [Array] names names of libraries to load @return [Array&lt;DynamicLibrary&gt;] @raise {LoadError} …\n"],["ffi_lib_flags","FFI::Library","FFI/Library.html#method-i-ffi_lib_flags","(*flags)","<p>Sets library flags for {#ffi_lib}.\n<p>@example\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">ffi_lib_flags</span>(<span class=\"ruby-value\">:lazy</span>, <span class=\"ruby-value\">:local</span>) <span class=\"ruby-comment\"># =&gt; 5</span>\n</pre>\n"],["ffi_libraries","FFI::Library","FFI/Library.html#method-i-ffi_libraries","()","<p>@see #ffi_lib @return [Array&lt;FFI::DynamicLibrary&gt;] array of currently loaded FFI libraries @raise …\n"],["field","FFI::StructGenerator","FFI/StructGenerator.html#method-i-field","(name, type=nil)",""],["field_for_type","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-field_for_type","(name, offset, type)","<p>@param (see #add) @return [StructLayout::Field]\n"],["find","FFI::Enum","FFI/Enum.html#method-i-find","(query)",""],["find","FFI::Enums","FFI/Enums.html#method-i-find","(query)","<p>@param query enum tag or part of an enum name @return [Enum] Find a {Enum} in collection.\n"],["find_field_type","FFI::Struct","FFI/Struct.html#method-c-find_field_type","(type, mod = enclosing_module)",""],["find_type","FFI","FFI.html#method-c-find_type","(name, type_map = nil)","<p>@param [Type, DataConverter, Symbol] name @param [Hash] type_map if nil, {FFI::TypeDefs} is used @return …\n"],["find_type","FFI::Library","FFI/Library.html#method-i-find_type","(t)","<p>@param [DataConverter, Type, Struct, Symbol] t type to find @return [Type] Find a type definition.\n"],["find_type","FFI::Struct","FFI/Struct.html#method-c-find_type","(type, mod = enclosing_module)",""],["for_fd","FFI::IO","FFI/IO.html#method-c-for_fd","(fd, mode = \"r\")","<p>@param [Integer] fd file decriptor @param [String] mode mode string @return [::IO] Synonym for IO::for_fd …\n"],["found?","FFI::StructGenerator","FFI/StructGenerator.html#method-i-found-3F","()",""],["free","FFI::AutoPointer","FFI/AutoPointer.html#method-i-free","()","<p>@return [nil] Free the pointer.\n"],["free","FFI::AutoPointer::Releaser","FFI/AutoPointer/Releaser.html#method-i-free","()","<p>@return [nil] Free pointer.\n"],["from_native","FFI::AutoPointer","FFI/AutoPointer.html#method-c-from_native","(val, ctx)","<p>Create a new AutoPointer.\n<p>Override {DataConverter#from_native}. @overload self.from_native(ptr, ctx)\n\n<pre class=\"ruby\"><span class=\"ruby-ivar\">@param</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["from_native","FFI::Bitmask","FFI/Bitmask.html#method-i-from_native","(val, ctx)","<p>@param [Integer] val @param ctx unused @return [Array&lt;Symbol, Integer&gt;] list of symbol names corresponding …\n"],["from_native","FFI::DataConverter","FFI/DataConverter.html#method-i-from_native","(value, ctx)","<p>Convert from a native type.\n"],["from_native","FFI::Enum","FFI/Enum.html#method-i-from_native","(val, ctx)","<p>@param val @return symbol name if it exists for <code>val</code>.\n"],["from_native","FFI::StrPtrConverter","FFI/StrPtrConverter.html#method-c-from_native","(val, ctx)","<p>@param [Pointer] val @param ctx not used @return [Array(String, Pointer)] Returns a [ String, Pointer …\n"],["from_native","FFI::Struct::ManagedStructConverter","FFI/Struct/ManagedStructConverter.html#method-i-from_native","(ptr, ctx)","<p>@param [Pointer] ptr @param [nil] ctx @return [Struct]\n"],["from_native","FFI::StructByReference","FFI/StructByReference.html#method-i-from_native","(value, ctx)","<p>@param [AbstractMemory] value @param [nil] ctx @return [Struct] Create a struct from content of memory …\n"],["function_names","FFI::Library","FFI/Library.html#method-i-function_names","(name, arg_types)","<p>@param [#to_s] name function name @param [Array] arg_types function&#39;s argument types @return [Array&lt;String&gt;] …\n"],["generate","FFI::TypesGenerator","FFI/TypesGenerator.html#method-c-generate","(options = {})",""],["generate_layout","FFI::StructGenerator","FFI/StructGenerator.html#method-i-generate_layout","()",""],["generic_enum","FFI::Library","FFI/Library.html#method-i-generic_enum","(klass, *args)","<p>Generic enum builder\n\n<pre>@param [Class] klass can be one of FFI::Enum or FFI::Bitmask\n@param args (see #enum ...</pre>\n"],["get","FFI::StructLayout::Enum","FFI/StructLayout/Enum.html#method-i-get","(ptr)","<p>@param [AbstractMemory] ptr pointer on a {Struct} @return [Object] Get an object of type {#type} from …\n"],["get","FFI::StructLayout::InnerStruct","FFI/StructLayout/InnerStruct.html#method-i-get","(ptr)",""],["get","FFI::StructLayout::Mapped","FFI/StructLayout/Mapped.html#method-i-get","(ptr)",""],["get_field","FFI::StructGenerator","FFI/StructGenerator.html#method-i-get_field","(name)",""],["hash_layout","FFI::Struct","FFI/Struct.html#method-c-hash_layout","(builder, spec)","<p>@param [StructLayoutBuilder] builder @param [Hash] spec @return [builder] Add hash <code>spec</code> to <code>builder</code>.\n"],["in","FFI::Struct","FFI/Struct.html#method-c-in","()",""],["include","FFI::ConstGenerator","FFI/ConstGenerator.html#method-i-include","(*i)","<p>Add additional C include file(s) to calculate constants from. @note <code>stdio.h</code> and <code>stddef.h</code> automatically …\n"],["include","FFI::StructGenerator","FFI/StructGenerator.html#method-i-include","(i)",""],["init","FFI::VariadicInvoker","FFI/VariadicInvoker.html#method-i-init","(arg_types, type_map)",""],["is_os","FFI::Platform","FFI/Platform.html#method-c-is_os","(os)","<p>@param [String) os @return [Boolean] Test if current OS is <code>os</code>.\n"],["layout","FFI::Struct","FFI/Struct.html#method-c-layout","(*spec)","<p>@return [StructLayout] @overload layout\n\n<pre>@return [StructLayout]\nGet struct layout.</pre>\n<p>@overload layout(*spec) …\n"],["mac?","FFI::Platform","FFI/Platform.html#method-c-mac-3F","()","<p>Test if current OS is Mac OS @return [Boolean]\n"],["map_library_name","FFI","FFI.html#method-c-map_library_name","(lib)","<p>@param [#to_s] lib library name @return [String] library name formatted for current platform Transform …\n"],["members","FFI::Struct","FFI/Struct.html#method-i-members","()","<p>(see FFI::StructLayout#members)\n"],["members","FFI::Struct","FFI/Struct.html#method-c-members","()","<p>(see FFI::Type#members)\n"],["name","FFI::StructGenerator","FFI/StructGenerator.html#method-i-name","(n)",""],["native_read","FFI::IO","FFI/IO.html#method-c-native_read","(io, buf, len)","<p>@param [#read] io io to read from @param [AbstractMemory] buf destination for data read from <code>io</code> @param …\n"],["native_type","FFI::AutoPointer","FFI/AutoPointer.html#method-c-native_type","()","<p>Return native type of AutoPointer.\n<p>Override {DataConverter#native_type}. @return [Type::POINTER] @raise …\n"],["native_type","FFI::DataConverter","FFI/DataConverter.html#method-i-native_type","(type = nil)","<p>Get native type.\n<p>@overload native_type(type)\n\n<pre>@param [String, Symbol, Type] type\n@return [Type]\nGet native ...</pre>\n"],["native_type","FFI::StructByReference","FFI/StructByReference.html#method-i-native_type","()","<p>Always get {FFI::Type}::POINTER.\n"],["new","FFI::AutoPointer","FFI/AutoPointer.html#method-c-new","(ptr, proc=nil, &block)","<p>@overload initialize(pointer, method)\n\n<pre>@param pointer [Pointer]\n@param method [Method]\n@return [self]\nThe ...</pre>\n"],["new","FFI::AutoPointer::Releaser","FFI/AutoPointer/Releaser.html#method-c-new","(ptr, proc)","<p>@param [Pointer] ptr @param [#call] proc @return [nil] A new instance of Releaser.\n"],["new","FFI::Bitmask","FFI/Bitmask.html#method-c-new","(*args)","<p>@overload initialize(info, tag=nil)\n\n<pre>@param [nil, Enumerable] info symbols and bit rank for new Bitmask ...</pre>\n"],["new","FFI::ConstGenerator","FFI/ConstGenerator.html#method-c-new","(prefix = nil, options = {})","<p>Creates a new constant generator that uses <code>prefix</code> as a name, and an options hash.\n<p>The only option is  …\n"],["new","FFI::ConstGenerator::Constant","FFI/ConstGenerator/Constant.html#method-c-new","(name, format, cast, ruby_name = nil, converter=nil)","<p>@param [#to_s] name @param [String] format a printf format string to print the value out @param [String] …\n"],["new","FFI::Enum","FFI/Enum.html#method-c-new","(*args)","<p>@overload initialize(info, tag=nil)\n\n<pre>@param [nil, Enumerable] info\n@param [nil, Symbol] tag enum tag</pre>\n<p>@overload …\n"],["new","FFI::Enums","FFI/Enums.html#method-c-new","()","<p>@return [nil]\n"],["new","FFI::Generator","FFI/Generator.html#method-c-new","(ffi_name, rb_name, options = {})",""],["new","FFI::Generator::Task","FFI/Generator/Task.html#method-c-new","(rb_names, options={})",""],["new","FFI::ManagedStruct","FFI/ManagedStruct.html#method-c-new","(pointer=nil)","<p>@overload initialize(pointer)\n\n<pre>@param [Pointer] pointer\nCreate a new ManagedStruct which will invoke the ...</pre>\n"],["new","FFI::NotFoundError","FFI/NotFoundError.html#method-c-new","(function, *libraries)",""],["new","FFI::Struct::ManagedStructConverter","FFI/Struct/ManagedStructConverter.html#method-c-new","(struct_class)","<p>@param [Struct] struct_class\n"],["new","FFI::StructByReference","FFI/StructByReference.html#method-c-new","(struct_class)","<p>@param [Struct] struct_class\n"],["new","FFI::StructGenerator","FFI/StructGenerator.html#method-c-new","(name, options = {})",""],["new","FFI::StructGenerator::Field","FFI/StructGenerator/Field.html#method-c-new","(name, type)",""],["new","FFI::StructLayout::Mapped","FFI/StructLayout/Mapped.html#method-c-new","(name, offset, type, orig_field)",""],["new","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-c-new","()",""],["offset=","FFI::StructGenerator::Field","FFI/StructGenerator/Field.html#method-i-offset-3D","(o)",""],["offset_of","FFI::Struct","FFI/Struct.html#method-c-offset_of","(name)","<p>(see FFI::StructLayout#offset_of)\n"],["offset_of","FFI::Struct","FFI/Struct.html#method-i-offset_of","(name)","<p>(see FFI::StructLayout#offset_of)\n"],["offset_of","FFI::StructLayout","FFI/StructLayout.html#method-i-offset_of","(field_name)","<p>@return [Numeric] Get the offset of a field.\n"],["offsets","FFI::Struct","FFI/Struct.html#method-i-offsets","()","<p>(see FFI::StructLayout#offsets)\n"],["offsets","FFI::Struct","FFI/Struct.html#method-c-offsets","()","<p>(see FFI::StructLayout#offsets)\n"],["offsets","FFI::StructLayout","FFI/StructLayout.html#method-i-offsets","()","<p>@return [Array&lt;Array(Symbol, Numeric)&gt; Get an array of tuples (field name, offset of the field). …\n"],["options","FFI::ConstGenerator","FFI/ConstGenerator.html#method-c-options","()","<p>Get class options. @return [Hash] class options\n"],["options","FFI::StructGenerator","FFI/StructGenerator.html#method-c-options","()",""],["options=","FFI::ConstGenerator","FFI/ConstGenerator.html#method-c-options-3D","(options)","<p>Set class options These options are merged with {#initialize} options when it is called with a block. …\n"],["options=","FFI::StructGenerator","FFI/StructGenerator.html#method-c-options-3D","(options)",""],["out","FFI::Struct","FFI/Struct.html#method-c-out","()",""],["pack","FFI::Struct","FFI/Struct.html#method-c-pack","(packed = 1)",""],["packed","FFI::Struct","FFI/Struct.html#method-c-packed","(packed = 1)",""],["packed=","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-packed-3D","(packed)","<p>Set packed attribute @overload packed=(packed) Set alignment and packed attributes to\n\n<pre>+packed+.\n\n@param ...</pre>\n"],["ptr","FFI::Struct","FFI/Struct.html#method-c-ptr","(flags = :inout)",""],["put","FFI::StructLayout::Enum","FFI/StructLayout/Enum.html#method-i-put","(ptr, value)","<p>@param [AbstractMemory] ptr pointer on a {Struct} @param  value @return [nil] Set <code>value</code> into memory pointed …\n"],["put","FFI::StructLayout::InnerStruct","FFI/StructLayout/InnerStruct.html#method-i-put","(ptr, value)",""],["put","FFI::StructLayout::Mapped","FFI/StructLayout/Mapped.html#method-i-put","(ptr, value)",""],["read","FFI::Pointer","FFI/Pointer.html#method-i-read","(type)","<p>@param [Symbol,Type] type of data to read @return [Object] Read pointer&#39;s contents as <code>type</code>\n<p>Same as: …\n"],["read_array_of_type","FFI::Pointer","FFI/Pointer.html#method-i-read_array_of_type","(type, reader, length)","<p>@param [Type] type type of data to read from pointer&#39;s contents @param [Symbol] reader method to …\n"],["read_string","FFI::Pointer","FFI/Pointer.html#method-i-read_string","(len=nil)","<p>@param [nil,Numeric] len length of string to return @return [String] Read pointer&#39;s contents as a …\n"],["read_string_length","FFI::Pointer","FFI/Pointer.html#method-i-read_string_length","(len)","<p>@param [Numeric] len length of string to return @return [String] Read the first <code>len</code> bytes of pointer&#39;s …\n"],["read_string_to_null","FFI::Pointer","FFI/Pointer.html#method-i-read_string_to_null","()","<p>@return [String] Read pointer&#39;s contents as a string.\n<p>Same as:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">ptr</span>.<span class=\"ruby-identifier\">read_string</span>  <span class=\"ruby-comment\"># with no len</span>\n</pre>\n"],["release","FFI::AutoPointer::CallableReleaser","FFI/AutoPointer/CallableReleaser.html#method-i-release","(ptr)","<p>Release <code>ptr</code> by using Proc or Method defined at <code>ptr</code> {AutoPointer#initialize initialization}.\n<p>@param [Pointer] …\n"],["release","FFI::AutoPointer::DefaultReleaser","FFI/AutoPointer/DefaultReleaser.html#method-i-release","(ptr)","<p>@param [Pointer] ptr @return [nil] Release <code>ptr</code> using the {release} class method of its class.\n"],["ruby_name","FFI::ConstGenerator::Constant","FFI/ConstGenerator/Constant.html#method-i-ruby_name","()","<p>get constant ruby name @return [String]\n"],["size","FFI::Pointer","FFI/Pointer.html#method-c-size","()","<p>Return the size of a pointer on the current platform, in bytes @return [Numeric]\n"],["size","FFI::Struct","FFI/Struct.html#method-c-size","()","<p>Get struct size @return [Numeric]\n"],["size","FFI::Struct","FFI/Struct.html#method-i-size","()","<p>Get struct size @return [Numeric]\n"],["size=","FFI::Struct","FFI/Struct.html#method-c-size-3D","(size)","<p>set struct size @param [Numeric] size @return [size]\n"],["size=","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-size-3D","(size)","<p>Set size attribute with <code>size</code> only if <code>size</code> is greater than attribute value. @param [Numeric] size\n"],["solaris?","FFI::Platform","FFI/Platform.html#method-c-solaris-3F","()","<p>Test if current OS is Solaris (Sun OS) @return [Boolean]\n"],["struct","FFI::Generator","FFI/Generator.html#method-i-struct","(options = {}, &block)",""],["symbol_map","FFI::Enum","FFI/Enum.html#method-i-symbol_map","()","<p>Get the symbol map. @return [Hash]\n"],["symbols","FFI::Enum","FFI/Enum.html#method-i-symbols","()","<p>@return [Array] enum symbol names\n"],["to_config","FFI::StructGenerator::Field","FFI/StructGenerator/Field.html#method-i-to_config","(name)",""],["to_h","FFI::Enum","FFI/Enum.html#method-i-to_h","()",""],["to_hash","FFI::Enum","FFI/Enum.html#method-i-to_hash","()",""],["to_native","FFI::Bitmask","FFI/Bitmask.html#method-i-to_native","(query, ctx)","<p>Get the native value of a bitmask @overload to_native(query, ctx)\n\n<pre>@param [Symbol, Integer, #to_int] query ...</pre>\n"],["to_native","FFI::DataConverter","FFI/DataConverter.html#method-i-to_native","(value, ctx)","<p>Convert to a native type.\n"],["to_native","FFI::Enum","FFI/Enum.html#method-i-to_native","(val, ctx)","<p>@param [Symbol, Integer, #to_int] val @param ctx unused @return [Integer] value of a enum symbol\n"],["to_native","FFI::StructByReference","FFI/StructByReference.html#method-i-to_native","(value, ctx)","<p>@param [nil, Struct] value @param [nil] ctx @return [AbstractMemory] Pointer on <code>value</code>.\n"],["to_ptr","FFI::Pointer","FFI/Pointer.html#method-i-to_ptr","()","<p>@return [self]\n"],["to_ptr","FFI::Struct","FFI/Struct.html#method-i-to_ptr","()","<p>Get {Pointer} to struct content. @return [AbstractMemory]\n"],["to_ruby","FFI::ConstGenerator","FFI/ConstGenerator.html#method-i-to_ruby","()","<p>Outputs values for discovered constants.  If the constant&#39;s value was not discovered it is not omitted. …\n"],["to_ruby","FFI::ConstGenerator::Constant","FFI/ConstGenerator/Constant.html#method-i-to_ruby","()","<p>Get an evaluable string from constant. @return [String]\n"],["to_s","FFI::Generator","FFI/Generator.html#method-i-to_s","()","<p>Utility converter for constants\n"],["type_size","FFI","FFI.html#method-c-type_size","(type)","<p>@param type <code>type</code> is an instance of class accepted by {FFI.find_type} @return [Numeric] Get <code>type</code> size, …\n"],["typedef","FFI","FFI.html#method-c-typedef","(old, add)","<p>@param [Type, DataConverter, Symbol] old type definition used by {FFI.find_type} @param [Symbol] add …\n"],["typedef","FFI::Library","FFI/Library.html#method-i-typedef","(old, add, info=nil)","<p>Register or get an already registered type definition.\n<p>To register a new type definition, <code>old</code> should be …\n"],["union=","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-union-3D","(is_union)","<p>Set union attribute. Set to <code>true</code> to build a {Union} instead of a {Struct}. @param [Boolean] is_union …\n"],["union?","FFI::StructLayoutBuilder","FFI/StructLayoutBuilder.html#method-i-union-3F","()","<p>Building a {Union} or a {Struct} ?\n<p>@return [Boolean]\n"],["unix?","FFI::Platform","FFI/Platform.html#method-c-unix-3F","()","<p>Test if current OS is a unix OS @return [Boolean]\n"],["val","FFI::Struct","FFI/Struct.html#method-c-val","()",""],["values","FFI::Struct","FFI/Struct.html#method-i-values","()","<p>@return [Array] Get array of values from Struct fields.\n"],["windows?","FFI::Platform","FFI/Platform.html#method-c-windows-3F","()","<p>Test if current OS is Windows @return [Boolean]\n"],["write","FFI::Pointer","FFI/Pointer.html#method-i-write","(type, value)","<p>@param [Symbol,Type] type of data to read @param [Object] value to write @return [nil] Write <code>value</code> of …\n"],["write_array_of_type","FFI::Pointer","FFI/Pointer.html#method-i-write_array_of_type","(type, writer, ary)","<p>@param [Type] type type of data to write to pointer&#39;s contents @param [Symbol] writer method to send …\n"],["write_string","FFI::Pointer","FFI/Pointer.html#method-i-write_string","(str, len=nil)","<p>@param [String] str string to write @param [Numeric] len length of string to return @return [self] Write …\n"],["write_string_length","FFI::Pointer","FFI/Pointer.html#method-i-write_string_length","(str, len)","<p>@param [String] str string to write @param [Numeric] len length of string to return @return [self] Write …\n"],["types.conf","","lib/ffi/platform/aarch64-freebsd/types_conf.html","","<p>rbx.platform.typedef.__clock_t = int rbx.platform.typedef.__clockid_t = int rbx.platform.typedef.__cpuid_t …\n"],["types.conf","","lib/ffi/platform/aarch64-freebsd12/types_conf.html","","<p>rbx.platform.typedef.__clock_t = int rbx.platform.typedef.__clockid_t = int rbx.platform.typedef.__cpuid_t …\n"],["types.conf","","lib/ffi/platform/aarch64-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/arm-freebsd/types_conf.html","","<p>rbx.platform.typedef.*) = pointer rbx.platform.typedef.__accmode_t = int rbx.platform.typedef.__blkcnt_t …\n"],["types.conf","","lib/ffi/platform/arm-freebsd12/types_conf.html","","<p>rbx.platform.typedef.*) = pointer rbx.platform.typedef.__accmode_t = int rbx.platform.typedef.__blkcnt_t …\n"],["types.conf","","lib/ffi/platform/arm-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/i386-cygwin/types_conf.html","","<p>rbx.platform.typedef.ptrdiff_t = int rbx.platform.typedef.size_t = uint rbx.platform.typedef.ssize_t …\n"],["types.conf","","lib/ffi/platform/i386-darwin/types_conf.html","","<p>rbx.platform.typedef.__darwin_blkcnt_t = long_long rbx.platform.typedef.__darwin_blksize_t = int rbx.platform.typedef.__darwin_clock_t …\n"],["types.conf","","lib/ffi/platform/i386-freebsd/types_conf.html","","<p>rbx.platform.typedef.*) = pointer rbx.platform.typedef.__accmode_t = int rbx.platform.typedef.__blkcnt_t …\n"],["types.conf","","lib/ffi/platform/i386-freebsd12/types_conf.html","","<p>rbx.platform.typedef.*) = pointer rbx.platform.typedef.__accmode_t = int rbx.platform.typedef.__blkcnt_t …\n"],["types.conf","","lib/ffi/platform/i386-gnu/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/i386-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/i386-netbsd/types_conf.html","","<p>rbx.platform.typedef.__clock_t = int rbx.platform.typedef.__clockid_t = int rbx.platform.typedef.__cpuid_t …\n"],["types.conf","","lib/ffi/platform/i386-openbsd/types_conf.html","","<p>rbx.platform.typedef.__clock_t = int rbx.platform.typedef.__clockid_t = int rbx.platform.typedef.__cpuid_t …\n"],["types.conf","","lib/ffi/platform/i386-solaris/types_conf.html","","<p>rbx.platform.typedef.*caddr_t = char rbx.platform.typedef.blkcnt64_t = long_long rbx.platform.typedef.blkcnt_t …\n"],["types.conf","","lib/ffi/platform/i386-windows/types_conf.html","","<p>rbx.platform.typedef.*addr_t = char rbx.platform.typedef.__ULong = ulong rbx.platform.typedef.__blkcnt32_t …\n"],["types.conf","","lib/ffi/platform/ia64-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mips-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mips64-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mips64el-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mipsel-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mipsisa32r6-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mipsisa32r6el-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mipsisa64r6-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/mipsisa64r6el-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/powerpc-aix/types_conf.html","","<p>rbx.platform.typedef.UTF32Char = uint rbx.platform.typedef.UniChar = ushort rbx.platform.typedef.__cptr32 …\n"],["types.conf","","lib/ffi/platform/powerpc-darwin/types_conf.html","","<p>rbx.platform.typedef.__darwin_blkcnt_t = long_long rbx.platform.typedef.__darwin_blksize_t = int rbx.platform.typedef.__darwin_clock_t …\n"],["types.conf","","lib/ffi/platform/powerpc-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/powerpc64-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/s390-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/s390x-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/sparc-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long_long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/sparc-solaris/types_conf.html","","<p>rbx.platform.typedef.() = pointer rbx.platform.typedef.*caddr_t = char rbx.platform.typedef.Psocklen_t …\n"],["types.conf","","lib/ffi/platform/sparc64-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.*__qaddr_t = long rbx.platform.typedef.__blkcnt64_t …\n"],["types.conf","","lib/ffi/platform/sparcv9-solaris/types_conf.html","","<p>rbx.platform.typedef.() = pointer rbx.platform.typedef.*caddr_t = char rbx.platform.typedef.Psocklen_t …\n"],["types.conf","","lib/ffi/platform/x86_64-cygwin/types_conf.html","","<p>rbx.platform.typedef.ptrdiff_t = int64 rbx.platform.typedef.size_t = uint64 rbx.platform.typedef.ssize_t …\n"],["types.conf","","lib/ffi/platform/x86_64-darwin/types_conf.html","","<p>rbx.platform.typedef.__darwin_blkcnt_t = long_long rbx.platform.typedef.__darwin_blksize_t = int rbx.platform.typedef.__darwin_clock_t …\n"],["types.conf","","lib/ffi/platform/x86_64-dragonflybsd/types_conf.html","","<p>rbx.platform.typedef.*) = pointer rbx.platform.typedef.__char16_t = ushort rbx.platform.typedef.__char32_t …\n"],["types.conf","","lib/ffi/platform/x86_64-freebsd/types_conf.html","","<p>rbx.platform.typedef.__clock_t = int rbx.platform.typedef.__clockid_t = int rbx.platform.typedef.__cpuid_t …\n"],["types.conf","","lib/ffi/platform/x86_64-freebsd12/types_conf.html","","<p>rbx.platform.typedef.*) = pointer rbx.platform.typedef.___wchar_t = int rbx.platform.typedef.__accmode_t …\n"],["types.conf","","lib/ffi/platform/x86_64-linux/types_conf.html","","<p>rbx.platform.typedef.*__caddr_t = char rbx.platform.typedef.__blkcnt64_t = long rbx.platform.typedef.__blkcnt_t …\n"],["types.conf","","lib/ffi/platform/x86_64-netbsd/types_conf.html","","<p>rbx.platform.typedef.__clock_t = int rbx.platform.typedef.__clockid_t = int rbx.platform.typedef.__cpuid_t …\n"],["types.conf","","lib/ffi/platform/x86_64-openbsd/types_conf.html","","<p>rbx.platform.typedef.__blkcnt_t = long_long rbx.platform.typedef.__blksize_t = int rbx.platform.typedef.__clock_t …\n"],["types.conf","","lib/ffi/platform/x86_64-solaris/types_conf.html","","<p>rbx.platform.typedef.*caddr_t = char rbx.platform.typedef.blkcnt64_t = long rbx.platform.typedef.blkcnt_t …\n"],["types.conf","","lib/ffi/platform/x86_64-windows/types_conf.html","","<p>rbx.platform.typedef.*addr_t = char rbx.platform.typedef.__ULong = ulong rbx.platform.typedef.__blkcnt32_t …\n"]]}}